#!/usr/bin/env node
/**
 * Sync Airtable Schema to Config
 *
 * This script fetches the schema from Airtable and updates the airtableConfig.ts
 * file with all field information for the configured tables.
 *
 * Usage:
 *   AIRTABLE_API_KEY=your_key npx tsx app/modules/extensions/hhmi-compliance/scripts/sync-airtable-schema.mts
 *
 * Or with inline args:
 *   npx tsx app/modules/extensions/hhmi-compliance/scripts/sync-airtable-schema.mts <api-key> <base-id>
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const AIRTABLE_API_KEY = process.env.AIRTABLE_API_KEY || process.argv[2];
const BASE_ID = process.env.AIRTABLE_BASE_ID || process.argv[3] || 'appuBoDw7bAfzfyK4';
const CONFIG_PATH = path.join(__dirname, '..', 'backend', 'airtableConfig.ts');

// Airtable Metadata API Types
interface AirtableFieldMetadata {
  id: string;
  name: string;
  type: string;
  description?: string;
  options?: Record<string, any>;
}

interface AirtableTableMetadata {
  id: string;
  name: string;
  primaryFieldId: string;
  fields: AirtableFieldMetadata[];
  views: any[];
  description?: string;
}

interface AirtableBaseMetadata {
  tables: AirtableTableMetadata[];
}

// Table IDs we care about
const TARGET_TABLES = {
  publications: 'tblZw5sCSjmxfd4PC',
  preprints: 'tblRWSiJvlOjt2OI4',
  scientists: 'tblKTlRedfiVcTo36',
};

/**
 * Fetch metadata from Airtable
 */
async function fetchAirtableMetadata(): Promise<AirtableBaseMetadata> {
  if (!AIRTABLE_API_KEY) {
    throw new Error(
      'AIRTABLE_API_KEY is required. Set it as an environment variable or pass as first argument.',
    );
  }

  console.log(`Fetching metadata for base ${BASE_ID}...`);

  const url = `https://api.airtable.com/v0/meta/bases/${BASE_ID}/tables`;
  const response = await fetch(url, {
    headers: {
      Authorization: `Bearer ${AIRTABLE_API_KEY}`,
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(`Airtable API error: ${response.status} - ${JSON.stringify(errorData)}`);
  }

  return await response.json();
}

/**
 * Convert field name to snake_case config key
 */
function fieldNameToKey(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, ''); // Remove leading/trailing underscores
}

/**
 * Generate the config object for a table
 */
function generateTableConfig(table: AirtableTableMetadata): string {
  const lines: string[] = [];

  lines.push(`    ${fieldNameToKey(table.name.toLowerCase())}: {`);
  lines.push(`      name: '${table.name}',`);
  lines.push(`      id: '${table.id}',`);
  lines.push(`      fields: {`);

  // Sort fields alphabetically by name for consistency
  const sortedFields = [...table.fields].sort((a, b) => a.name.localeCompare(b.name));

  for (const field of sortedFields) {
    const key = fieldNameToKey(field.name);
    lines.push(`        ${key}: {`);
    lines.push(`          name: '${field.name}',`);
    lines.push(`          id: '${field.id}',`);
    lines.push(`        },`);
  }

  lines.push(`      },`);
  lines.push(`    },`);

  return lines.join('\n');
}

/**
 * Generate the complete config file content
 */
function generateConfigFile(metadata: AirtableBaseMetadata): string {
  const lines: string[] = [];

  lines.push('// Airtable Configuration');
  lines.push(
    '// Auto-generated by app/modules/extensions/hhmi-compliance/scripts/sync-airtable-schema.mts',
  );
  lines.push('// Do not edit manually - run the script to update');
  lines.push('export const AIRTABLE_CONFIG = {');
  lines.push(`  baseId: '${BASE_ID}',`);
  lines.push('  tables: {');

  // Only include the tables we care about
  for (const [tableName, tableId] of Object.entries(TARGET_TABLES)) {
    const table = metadata.tables.find((t) => t.id === tableId);
    if (table) {
      console.log(`  ‚úì Found table: ${table.name} (${table.fields.length} fields)`);
      lines.push(generateTableConfig(table));
    } else {
      console.warn(`  ‚ö† Table ${tableName} (${tableId}) not found in base`);
    }
  }

  lines.push('  },');
  lines.push('};');
  lines.push('');

  return lines.join('\n');
}

/**
 * Main execution
 */
async function main() {
  try {
    console.log('üîÑ Syncing Airtable schema to config...\n');

    // Fetch metadata
    const metadata = await fetchAirtableMetadata();
    console.log(`\nFetched metadata for ${metadata.tables.length} tables\n`);

    // Generate new config
    const newConfig = generateConfigFile(metadata);

    // Backup existing config
    if (fs.existsSync(CONFIG_PATH)) {
      const backupPath = CONFIG_PATH.replace('.ts', '.backup.ts');
      fs.copyFileSync(CONFIG_PATH, backupPath);
      console.log(`\nüì¶ Backed up existing config to ${path.basename(backupPath)}`);
    }

    // Write new config
    fs.writeFileSync(CONFIG_PATH, newConfig, 'utf-8');
    console.log(`‚úÖ Updated ${path.relative(process.cwd(), CONFIG_PATH)}\n`);

    // Summary
    console.log('Summary:');
    const tables = metadata.tables.filter((t) => Object.values(TARGET_TABLES).includes(t.id));
    for (const table of tables) {
      console.log(`  - ${table.name}: ${table.fields.length} fields`);
    }

    console.log('\n‚ú® Done! Run your linter/formatter on the file if needed.\n');
  } catch (error) {
    console.error('\n‚ùå Error:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

main();
